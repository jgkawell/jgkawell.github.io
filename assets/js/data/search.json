[ { "title": "New Website!", "url": "/posts/new-website/", "categories": "misc", "tags": "website", "date": "2022-06-19 12:00:00 -0500", "snippet": "IntroductionAfter a number of years hosting my personal site on WordPress I’ve decided to move off the platform. In this blog post I’ll describe some of the reasons why for those who are curious. If you’re not curious, the new domain is here: jack.kawell.usAny new posts will be here on the new site and all existing posts have been copied here already. I’ve also posted notes on each of the old posts redirecting you to the new site. Not sure how long I’ll keep the old WordPress site up before I just have DNS redirect all traffic from jack-kawell.com to jack.kawell.us.DetailsWhy change?I originally started this site on WordPress just because I wanted an easy place to host my personal site to keep a resume and post random tutorials. It was cheap and easy to get up and running here and for the most part I’ve really liked it.Recently, however, I’ve been diving deep into FOSS (free open-source software) tools and self-hosting. In order to host this WordPress site I pay ~100USD/year so that I can host it at a custom domain. This isn’t terrible for someone who doesn’t have any technical prowess, but since I literally run software systems for a living it seems ridiculous to me to pay someone else to run things when I can do it for (almost) free and have a ton of fun learning some new tools.I’ve also been frustrated at the “freemium” model that WordPress runs on. They lure you in with many promises of how amazing your site can be but so much of that value is locked behind premium subscriptions and plugins. I just want a simple site where I can publish my content and I don’t want to have to pay for things as simple as dark mode.What am I doing now?I’ve decided to move to using Jekyll which is a dead simple static site generator. It allows you to use Markdown (which I love!) to write your site and has a huge amount of templates to choose from to hone in one the style and theme you want. It also is completely free and open-source and is the technology powering GitHub Pages so you can host it through GitHub for free and rely on GitHub’s uptime guarantees.I thought about self-hosting my site but since I spend a lot of time tinkering with my homelab I didn’t want to be dependent on having 100% uptime for the thousands (!!!) of monthly visitors who use my tutorials. So I’m going the route of hosting the site on GitHub and publishing it using GitHub pages. If you’re curious about the code you can find it here: github.com/jgkawell/jgkawell.github.ioI decided to use the Chirpy as my Jekyll theme since it’s super clean, and has all the things I want for my blog: dark mode, social links, archive timeline, tags and categories, etc. Further, it has built in commenting using giscus which is an awesome plugin to have commenting on a blog powered through GitHub Discussions.The final awesome piece is that all the configuration of the site is simply text files that I can edit just like all the other code I work with day to day. I can even check in changes to the git repo and it will automatically build and deploy it using GitHub Actions! CI/CD for the win!One last implementation detail. I used to use Google Domains as my registrar and DNS provider. I’ve since moved to Cloudflare and my costs were cut by 2/3! I’m a huge fan of Cloudflare after using them for the past month and now have multiple domains registered through them. Their free tier is awesome and they don’t charge registrar fees on top of the mandatory ones (like ICANN).ConclusionAs you can tell, I’m loving this new set up and hope to be posting new content soon. If you have a site hosting tool you really like I’d love to hear about it. Bonus points if it’s free and open-source. These types of tools have just been getting better over time and it makes me surprised I went so long paying for WordPress before changing." }, { "title": "Building a Custom SFF Development and Gaming PC", "url": "/posts/sff-development-gaming-pc/", "categories": "misc", "tags": "computer, diy, hobby, setup", "date": "2020-09-12 12:00:00 -0500", "snippet": " My SFF(ish) Custom PC Last year (Summer 2019) I decided to use some bonus money from work to finally build myself a custom PC. I’d wanted one for a while since building my first PC workstation for my job in a research lab and got hooked on PC hardware. My work involved a lot of heavy compute so there was a practical reason as well as a fun reason. I spent a full year planning it out and then made the jump to purchase and build the machine. I originally posted the below breakdown of everything on the awesome site PC Part Picker here if you want to see a parts list.The RequirementsI had some pretty hefty requirements for this build as I was designing it. Before we go into all the details of the build I’ll list them out below: A high performing development box that had plenty of RAM to run virtualization workloads and plenty of cores to run heavy C++ compiles. A great gaming rig that can run games at 60fps in both 1080p and 1440p at high settings. A good looking, small form factor (SFF) build that I can put on my desk and get a great feeling every time I look at it (yeah I know this isn’t practical but I spend a lot of time using this thing and want it to be aesthetically pleasing) A super quite machine that I’ll barely know is running even while it’s only a couple feet from my face. A machine that keeps temperatures under control (but not necessarily perfect) even while running heavy compiles or intense games.The Design All the boxes for the parts in the build So these were pretty lofty goals. Originally my plan was to use a Ryzen 2700x but I was a bit concerned about thermals since it’s a 95W TDP chip. Then when the Ryzen 3700x came out I new that was the perfect chip since it offers event better performance at only a 65W TDP. It’s not the coolest of chips but it’s miles ahead of the 2nd series Ryzen chips and man does it fly through tasks. Throwing the 16 threads of a compilation power this thing offers at compiles is a dream to watch. It simply rips through all of my code. The CPU of choice: Ryzen 3700X The GPU will be a bit contentious since I bought right before the 2070 SUPER came out, but I really wanted the 8-pin power on the end of the GPU since the case that I chose is pretty restrictive in terms of size (more on that later). Besides, the extra uptick in performance with the SUPER model is not something that I really notice. I’m not really a gamer (I use an Xbox controller to play on this thing :b) so the 2070 has plenty of performance for my needs. I could have gone with one of the new AMD cards, but I sometimes need CUDA for GPU accelerated tasks and Nvidia cards are better supported than AMD for those kind of things in my workflow. Great all around GPU: RTX 2070 Founder&#39;s Edition For the case I was originally going to use Corsair’s Crystal 280x because it’s relatively small and looks absolutely gorgeous. I’m a big fan of original case designs and that one ticked most of my boxes. However, once I saw the Phanteks Evolv Shift, I new that it was perfect for this build. It takes up even less space than the Crystal 280x and I love the truly novel layout that it uses. I also personally think that it’s the best looking case out there even though it’s been out for a few years. The one issue with this case that I knew going in is that it struggles with thermal performance. The front panel strangles your fans which means your CPU suffers and then the side glass panel strangles your GPU. I’ll talk about these later. This case is one of the best out there: Phanteks Evolv Shift I must say that I really just got the NZXT M22 for the looks. I knew there were better performing 120mm coolers out there but I simply couldn’t choose those when something as pretty as the M22 were available. After using it for a while it does look great, but performance seems a bit lacking. For one thing, the fan that is included is crazy loud. Originally I thought it was my case fans (I was using the basic Phanteks ones originally), but that NZXT fan on the M22 is just terrible at anything but super low RPMs. Soon after the initial build though I splurged on a bunch of Noctua redux fans and they are so so awesome. I now have two 140s at the front and two 120s on the bottom in a push-pull configuration on the M22’s radiator. This cooler design is gorgeous: NZXT M22 AIO For the rest of the components the choices were a little easier. For the motherboard I knew I wanted to go B450 to simply save on cost (X570 is just not worth it for me since I don’t need PCIe 4.0) and with limited options for ITX B450 boards I simply went with this Strix board since it’s very highly rated and I got an amazing deal from Micro Center by bundling it with my AMD CPU. For the memory I new I wanted &amp;gt;3000MHz since 3rd gen Ryzen loves it and got this kit for cheap from a friend. I’ve actually used the Crucial P1 SSD in my laptop for a while and I think it’s got to be the best value SSD on the market right now.The Build Laying out the parts to build Alright, now for the actual build. Building in the Evolv Shift is not easy. This was my third custom PC build and by far the hardest I’d ever done (both of the others were in typical mid towers). However, I actually relished the challenge. There were a lot of steps that had to be redone and I went about the whole process very slowly over the course of an entire week. I’d highly recommend that approach with this case as you can’t approach it like a typical build at all.However, this case is so so so well built. It’s well thought out and there are places to run and manage cables in all the right spots. Just make sure you spend time checking for compatibility first so you know everything will fit just right. I loved building in this case as it brings such a nice challenge that is so rewarding by the end. Bringing it all together. The cable management is so well thought out in this case. And rewarding it really is. This case looks amazing and I’m so happy with the final product. All the parts have a seamless black, gray, and silver coloring and with a splash of RGB the thing just pops. I have it sitting right next to me on my desk and love seeing it every day I sit down to work or game.The ResultsThe size, and looks of the build I immediately knew were a success, but let’s now talk about the acoustics, performance, and thermals.AcousticsWith the stock fans, this thing was loud. I was really disappointed at first but after swapping all the fans for Noctua’s redux ones the whole thing was near silent at idle. I have the CPU fans on the radiator set at only 800rpm at idle and the front case fans set at 500rpm. With this setup the pump is actually the loudest part of the CPU cooling which is nearly silent.However, I quickly noticed that the GPU was making most of the noise in the system. On the 2070 Founder’s Edition that I have the fans can only be reduced to a minimum speed of 41%. Because of this, I actually flashed a different bios on the card so that I could further reduce the fan speed and make the thing nearly silent at idle. This type of BIOS flashing is a little dangerous, but very rewarding. You can read about what I did on this Reddit post here: https://www.reddit.com/r/nvidia/comments/e0z36b/bios_flashing_with_the_rtx_2070_fe/With that modification and setting the GPU fans to about 28% at idle, the thing is just a whisper. Obviously I have fan curves set up on all the fans so it gets much louder under load, but I love that I can be watching a video or debugging things on the web and the only noise is the very soft sounds of air moving through the case.CPU Performance Mounting the NZXT M22 on the Ryzen 3700X This thing absolutely flies. I’ve mentioned it above, but it completely crushes CPU tasks that I regularly do like lengthy compiles. I compared it to my work machine which has an non-K Intel 8700 (6c/12t) and it does my largest compile in a time that is a solid 20% faster. That’s huge in improving my work efficiency. Everyday tasks for me involve running multiple VMs (Docker and WSL), running Python and C++ projects, and the occasional Java project. All of these are done wicked fast so I have no complaints. Here are some CPU benchmarks I ran for you to get an idea: Cinebench R20 (multi-core) 4749 Cinebench R20 (single-core) 495 CPU-Z (multi-core) 5458 CPU-Z (single-core) 511 3DMARK Time Spy (CPU) 9896 3700X Performance on Common BenchmarksGPU Performance The RTX 2070 FE cooler looks awesome The RTX 2070 Founder’s Edition is a great card. It has some thermal and sound issues (I’ll mention more on this below), but performance is great. Like I said before, I don’t do a ton of gaming but my favorite franchise is Assassin’s Creed so it needs to be able to handle pretty demanding games. When building this rig I only had a 1080p 60Hz monitor though so the 2070 was definitely overkill. Since then, however, I upgraded to a 1440p ultrawide monitor at 100Hz and the 2070 is maxed out but still performs super well. I’ve played everything from simple shooters like The Division to rich games like AC Odyssey and the 2070 churns through with the settings optimized (mostly high presets). Here are some benchmarks for a better comparison to similar rigs: 3DMARK Time Spy (GPU) 9557 3DMARK Time Spy (combined) 9843 Unigine Heaven Benchmark 4.0 see below FPS 214.1 Score 51.3 Minimum FPS 51.3 RTX 2070 Founder&#39;s Edition Common BenchmarksThermals Having a total of four fans in a case this small really helps keep air moving Temperatures in this case and with this hardware is where things get fairly interesting. Like I mentioned above, the case cramps airflow and the CPU cooler I chose is not the most efficient on the market. I tested different fan configurations and finally settled on having the CPU radiator mounted at the bottom of the case with two 120mm fans in push-pull exhausting out of the case. I also have two 140mm fans mounted to the front of the case with both pulling fresh air in. The bottom 140 front fan feeds the radiator fans for the CPU and the top 140 front fan cools the motherboard and send a little bit of air to the GPU. With this configuration my CPU idles around 50C and under stress testing it maxes out at 84C (all of this is with fans at max RPM for testing). Under the heavy workloads I typically throw at it the CPU never even gets up to 80C (with normal fan speeds). CPU at idle 48C CPU under load 84C Ryzen 3700X Temperatures in Evolv ShiftAlso, I like to have my GPU turned with the fans facing outward (towards the glass) which is definitely not the best for temperatures but looks awesome. If you leave the glass panel on in this configuration while gaming the card quickly heats up and thermal throttles. To fix this I simply take the glass off when gaming and the GPU stays at a very comfortable temperature even when pegged in heavy games.Phanteks is dragging their feet on officially releasing the Shift Air mesh side panels but I’m definitely replacing my GPU panel with one of those as soon as I can. Since I reduced the fan speed at idle the idle temps are fairly high in the mid 50s with the side panel on. Under load the GPU will thermal throttle with the glass panel on but without it they stay in the 70s. I’ll update this post when I get the mesh panel to reflect the new idle and load temps. GPU at idle (glass on) mid 50s C GPU under load (glass on) 84C GPU at idle (glass off) mid 40s C GPU under load (glass off) mid 70s C RTX 2070 Founder&#39;s Edition Temperatures in Evolv Shift UPDATE: After a long wait I eventually was able to get a Evolv Shift Air mesh side panel for my GPU. After replacing the glass panel with the mesh I saw much better temperatures performance. Basically the temperatures behave the same as with the glass panel completely removed (so the second set of temperatures in the chart above). Noise levels barely increased any at idle and CPU temperatures were unaffected. I’m very pleased with with the type of mesh as well since it does a great job of capturing dust before it gets into the case and all I have to do is vacuum it every month or so.Conclusion My full setup with the finished build running the show Overall I’m very very pleased with this build. It does everything I set out for it to do and so meets all of my goals. I used builds on sites like PC Part Picker, the various PC building subreddits, and reviews across the web to come up with this build and make sure I was getting the best value for the money I spent. That being said, I’m really grateful for the community in the PC hardware space for the help and would love to answer any questions or hear any comments you all have about the build." }, { "title": "Setting up ROS in Windows through WSL2", "url": "/posts/ros-windows-wsl2/", "categories": "development, tutorial", "tags": "linux, windows, wsl", "date": "2020-06-12 12:00:00 -0500", "snippet": "IntroductionThis post is a tutorial on how to set up a working ROS development environment within Windows (complete with GUI support) utilizing the new Windows Subsystem for Linux 2 (WSL2). I wrote a similar post to this previously describing how to do it for WSL1 and a lot of that info carries over here. If you want to learn about why I choose to use WSL instead of a Virtual Machine (VM) or dual-booting into Linux, you can read about that in the above post.Before we get started I’d like to point out that my previous post on this topic for WSL1 has been a major hit. That blog post gets hundreds of views per week and I’m blown away by how many people have been helped by it. I want you all to know that I really appreciate all the feedback I get and that I actively check the comments on this blog so don’t be shy and reach out with comments and questions!NOTE #1: If you’d like to know how to set this up in Docker, I have another tutorial here that shows how to do that.NOTE #2: You have to be running Windows 10 version 2004 (Build 19041) or higher for WSL2 to work.WSL InstallationWSL2 is a complete reworking of WSL that shifts from what was essentially an emulation based approach to a virtualization based approach. WSL2 comes with a full Linux kernel and runs as a very lightweight VM on top of hypervisor. This gives tremendous improvements to performance over WSL1 specifically when it comes to boot times and I/O performance (we’re talking up to 20x speed improvements).Installing and setting up WSL2 is pretty straightforward (you can see the full docs here). First, you need to enable the WSL optional feature in Windows so open up a PowerShell prompt as Administrator and run this command:dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestartIf we were going to use WSL1 that is all we would have to do, but to use WSL2 there are a couple extra steps. You need to enable the Virtual Machine Platform optional feature by running the below command in PowerShell as Administrator:dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestartYou then need to restart your machine to finish the WSL install and the upgrade to WSL2.After the restart, we want to make sure that WSL2 is our default WSL version so that any Linux distros installed from here on out will be WSL2 (though you can always upgrade or downgrade distros later on). To set WSL2 as the default, run the below command in a PowerShell prompt:wsl --set-default-version 2After running this command, you may see this message: WSL 2 requires an update to its kernel component. For information please visit https://aka.ms/wsl2kernel. If you do, go to the link in the message and update your Linux kernel by installing the MSI that you download from that site. Once the kernel is installed, run the above command again and verify that the message doesn’t appear.If you already have a WSL1 installation, you can upgrade it to WSL2 using the below command and just replace &amp;lt;distribution name&amp;gt; with the name of the distro you want to upgrade:wsl --list --verbose #list wsl distroswsl --set-version &amp;lt;distribution name&amp;gt; 2 #change a distro to WSL2If you don’t already have Ubuntu installed through WSL1, let’s go ahead and install it now! Head over to the Microsoft Store app and search for “linux”. Click “Show all” to see all Linux distros This will give you a bunch of options including Kali, Ubuntu, Debian, and others. For ROS we need Ubuntu installed and in this tutorial I will choose Ubuntu 18.04 LTS. Keep in mind that Ubuntu and ROS versions are paired with each other: e.g. 16.04/Kinetic and 18.04/Melodic. They don’t work interchangeably. So in this walkthrough I will install Ubuntu 18.04 and then later we’ll install ROS Melodic.All that being said, simply click on your Ubuntu version of choice and then click install. This might take a bit depending on your internet speeds since the distribution is fairly large.Now we can launch that app and it will take a bit the first time as it needs to run through the initialization of the OS (remember that we are installing a complete operating system here). However, every other boot of WSL will only take a couple of seconds.Now you’re in! You have an (almost) fully-featured version of Ubuntu running within Windows with minimal resources being taken up and the ability to launch and kill it in a matter of seconds.NOTE: Your WSL2 filesystem resides within your file explorer at \\\\wsl$\\Ubuntu-18.04Setting up GUI forwardingThere are many X-server applications that will allow for GUI forwarding from WSL2, but my favorite one is VcXsrv. Go here to download and install it.Once you run the installer you can launch it from the Start menu in order to set it up. You can choose the defaults for the display settings and how to start clients. For the extra settings make sure to uncheck “Native opengl” and to check “Disable access control”. Right before you click “finish” you can select “Save configuration” so that you can simply double-click the config file to launch VcXsrv with these custom settings. This is a bit faster than clicking through every time. Example of adjusted VcXsrv settings Once you click “finish” you should see the VcXsrv icon down in your icon tray which means the server is running.NOTE: Some people have said that they run into issues with OpenGL applications like Rviz. If you do, try setting the environment variable LIBGL_ALWAYS_INDIRECT=0 in your WSL2 terminal (you can just add export LIBGL_ALWAYS_INDIRECT=0 to the end of your .bashrc file).Once that’s set up, we need to set the DISPLAY environment variable which tells WSL2 where to send the graphics for any application that needs a display to function. To do this, you’ll need to know the IP address for the Windows host machine. You can find this by going to Settings -&amp;gt; Network &amp;amp;amp; Internet and looking under the properties of your current connection (it will probably be labeled as “IPv4 Address”). Then run this command and replace {your_ip_address} with your IP address:echo &#39;export DISPLAY={your_ip_address}:0.0&#39; &amp;gt;&amp;gt; ~/.bashrcNOTE #1: If you’re running this on a laptop then your IP address will change as you move from network to network. Also, if you’re on a larger network (at a school campus or big company) you’re IP may change from time to time. Just keep in mind that you may need to update this IP address every once in a while.NOTE #2: You may have some issue using the IP address shown in Windows settings. If you do you may have success using the method on this StackOverflow answer. (credit to Ane for pointing this out)Now source your edited .bashrc file:source ~/.bashrcNow everything should be setup for GUI apps to be sent on to Windows for rendering and display. If you want to test the setup, you can install some basic apps within Ubuntu with the below package:sudo apt updatesudo apt install x11-appsAnd then run:xcalcTo run one of the apps. You can also install any of your favorite GUI apps or test it with ROS after we install that. Speaking of which…ROS InstallationNow to install ROS. The ROS team has a great installation guide over here for the different ROS versions on different OSes but here we’re just going to do the steps for Ubuntu 18.04/ROS Melodic. Go here for more details.First, make sure your version of Ubuntu has all the latest updates (all the commands below should be run from the shell within the Ubuntu app or from the same shell but in the Windows Terminal):sudo apt updatesudo apt upgradeThen we need to add the ROS package information to the sources list on our WSL system. To do this, run the below command:sudo sh -c &#39;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &amp;gt; /etc/apt/sources.list.d/ros-latest.list&#39;Now we need to setup the keys for these package repositories:sudo apt-key adv --keyserver &#39;hkp://keyserver.ubuntu.com:80&#39; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654NOTE: If you get some errors with the above command try substituting hkp://pgp.mit.edu:80.Now we need to update the local list of available packages with these newly added ROS ones:sudo apt updateNow we’re (finally) ready to install ROS. There’s a few options to choose from: desktop-full: This includes everything; rqt, rviz, simulators, navigation, perception, you name it. desktop: This has most of the above but lacks the simulators, navigators, and perception. ros-base: This is just the basics for getting up and running with ROS. No GUI tools and only what you need to package, build, and communicate over the ROS stack.My recommendation is to go with desktop-full unless you are super short on storage. It’ll take a bit more time for the initial install and take up more disk space, but you’re guaranteed to have most of the tools you need for anything you’d like to do. However, with all of these you can simply add more tools as you need them. Simply run apt-cache search ros-melodic to find which ones are available.Once you’ve chosen the ROS installation you want to get, run the below command and substitute in your choice. I’ll do desktop-full here:sudo apt install ros-melodic-desktop-fullDepending on your network speed, this might take a while to install.ROS needs to be sourced each time you open a bash shell and so we can add it to the ~/.bashrc file using the below commands to add it to the file and then source the file (you can manually source ROS every time but that defeats the point of making this a dedicated ROS development environment):echo &quot;source /opt/ros/melodic/setup.bash&quot; &amp;gt;&amp;gt; ~/.bashrcsource ~/.bashrcA couple last things to do. For most ROS development you’ll want to be able to build your own packages. So we need a couple more packages in order to make this work. Install them with the following command:sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essentialWe also need to initialize the dependency manager for ROS. Simply run these three commands:sudo apt install python-rosdepsudo rosdep initrosdep updateAnd now let’s test the whole setup by trying to launch Rviz:roscore &amp;amp;amp; rosrun rviz rvizIf it worked you should now see a window like the one below: Example of Rviz running in Windows through WSL2 And you’re done! Welcome to ROS on Windows!ConclusionThough this post is pretty long, none of this is actually too hard to setup and can be done in a matter of a few minutes (not including install times). It offers a painless way to get started in ROS development on Windows for those who don’t want to run a VM or dual-boot their systems.Once everything has been done above, you’re ready for some ROS development. Not everything will be supported in ROS with this setup (GPU support is coming in the future), but the basics are all there for most development needs. If you’re new to ROS, I’d suggest walking through the tutorials here to get a handle on things. At least go through the Beginner Level (you can just do one or the other of the C++ and Python ones) so that you have a good foundation to work off of.I hope this is helpful to somebody and if you have any thoughts on how to improve this tutorial don’t hesitate to let me know with a comment." }, { "title": "Create .bashrc files for Command Prompt and PowerShell in Windows", "url": "/posts/cmd-powershell-bashrc/", "categories": "development, tutorial", "tags": "windows, powershell, cmd", "date": "2020-03-18 12:00:00 -0500", "snippet": "Create .bashrc files for Command Prompt and PowerShell in WindowsAs someone who uses Linux a lot as my development workflow I’ve gotten used to the great power and flexibility of .bashrc files. If you’re not familiar with Linux (really Unix-based systems in general) a .bashrc file allows you to customize certain things about your user shell by adding things like aliases, functions, different visuals, etc. A .bashrc file is really just a shell script that runs when you open a new shell so that everything is set up before you even hit the command line.Since I do the vast majority of my development through WSL in Windows 10, I have a custom .bashrc file for each of my WSL distributions. However, I’ve often wanted the same functionality in Command Prompt (cmd) or PowerShell when I need to use those for Windows specific workflows. There are many different ways to set these types of things up, but after much experimentation across the web I’ve come up with two reliable ways to get the functionality I wanted.Setting up Command PromptFor the cmd shell you need to create a .cmd file with whatever name you want (I called mine bashrc.cmd) and place it somewhere in your filesystem where it isn’t going to move around. I like to keep things organized in my Documents folder so mine is in %UserProfile%\\Douments\\Apps\\cmd\\bashrc.cmd.Below I have an example of a simple bashrc.cmd file which turns off printing the commands (line 1), sets the title of the cmd window (line 2), clears any text on the screen (line 3), and then prints some example text to the screen (line 4):@echo offtitle cmdclsecho &quot;Hello World&quot;Now in order for this file to run when the command prompt is started we need to turn it on through the Registry (you should make sure to backup your registry before making any changes, but the change we’re making is not in any way dangerous): In order to open the Registry press Win + R and type in regedit and then press enter. Then navigate to Computer\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Command Processor. Right click on the Command Processor folder and click New -&amp;amp;gt; String Value. Enter AutoRun and press enter. Now double-click on AutoRun and type in the full path to your bashrc.cmd file and then click OK.And that’s it! No restart needed, just open up a new cmd prompt and (if you used the example file from above) you should see the title read cmd and the output say “Hello World”. Feel free to adapt this file to your development needs! This file is really just a .bat file and so pretty much any command should work just fine.Setting up PowerShellSetting up .bashrc functionality is even easier in PowerShell since it natively supports a very similar ability called profiles. There are a few different ways to set up a PowerShell profile depending on if you want the profile to be enabled for all users or not. Below, we will just set up a profile for a single user since I think that is much more common (unless you’re an IT guy configuring development machines for a company).In order to create a profile for your user, all you have to do is create a profile.ps1 file in the directory %UserProfile%\\Documents\\WindowsPowerShell\\profile.ps1. This will enable the profile for the current user and all PowerShell shells. An example of this type of file is below which makes the title of the shell windows “PowerShell” (line 1), clears any screen output (line 2), and then prints some example text to the screen (line 3):[System.Console]::Title = &quot;PowerShell&quot;clearecho &quot;Hello World&quot;Now if you just try and open a PowerShell windows you’ll most likely get an error about execution policies since by default you can’t run PowerShell scripts that are unsigned. To get around this you need to open an elevated PowerShell prompt (run as Administrator) and run the below command:Set-ExecutionPolicy RemoteSigned -Scope CurrentUserThis command will allow local PowerShell scripts to execute even when unsigned (the profile script we created is unsigned) while refusing to run remote scripts if they are unsigned. The scope makes sure that this only is in effect for your current user.And now you’re done! Go ahead and open up a new PowerShell prompt and (if you used the example file from above) you should see the title say “PowerShell” and the output say “Hello World”. Feel free to modify the profile file however you’d like since it’s just a PowerShell script!ConclusionAnd that’s it! These are really easy to set up and have a ton of functionality that you can play with. Be sure to let me know if anything above is incorrect or confusing so I can update the post and also let me know of any particular things you end up doing with these .bashrc files for Windows as I’d love to integrate new ideas into my own workflow!" }, { "title": "Setting up Powerline in WSL and VS Code", "url": "/posts/powerline-wsl-vs-code/", "categories": "development, tutorial", "tags": "linux, windows, wsl", "date": "2019-11-04 11:00:00 -0600", "snippet": "As you can probably tell from my previous posts, I spend a lot of time developing in WSL. In addition to this, I use VS Code as my main text editor/IDE and love it. It’s such a great editor with a ton of functionality and endless extensions. While the basic WSL shell is alright, I recently found out about Powerline which basically adds a ton of visual aids and customization to your terminal. I wanted to try it out but ran into a couple hiccups getting it working. After doing some searching around I got it working, so I thought I’d include my solution here.Install and Set up PowerlineThe first step is to simply install the Powerline package. The easiest way to do this is through pip. We’ll install it with the --user flag so that it goes into our user directory:pip install --user powerline-statusNow we need to add Powerline to our .bashrc file so that it starts with each new shell we create. This is also pretty simple to do since we can just copy paste the following code into the bottom of your existing .bashrc file:# Add this to your PATH if it’s not already declaredexport PATH=$PATH:$HOME/.local/bin# Powerline configurationif [ -f $HOME/.local/lib/python2.7/site-packages/powerline/bindings/bash/powerline.sh ]; then $HOME/.local/bin/powerline-daemon -q POWERLINE_BASH_CONTINUATION=1 POWERLINE_BASH_SELECT=1 source $HOME/.local/lib/python2.7/site-packages/powerline/bindings/bash/powerline.shfiBefore you source this file we need to set up the Powerline fonts so that it will work with WSL (note that this is not the way you’d normally get the Powerline fonts working on a standard Linux installation).Set up Powerline FontsThe Powerline fonts are easily available from the powerline GitHub user so we can simply clone the repository and then install. Since this is WSL though, we need to install the fonts through Windows so that our terminal windows know how to find and display them.Start by opening a Powershell window. Navigate to some directory where you’re good cloning the repo to. Then you can clone the repository, install the fonts, and then remove the repository all in one set of commands:git clone https://github.com/powerline/fonts.gitcd fonts./install.ps1cd ..;rm -r -for ./fontsNOTE: By default, Windows won’t allow you to run Powershell scripts like this one. You may have to change the Execution Policy temporarily to allow the fonts install to proceed. You can find more about this here. Or you can simply do what I did and make the Execution Policy Unrestricted temporarily and then turn it back to Default. Run this command to turn it off:Set-ExecutionPolicy UnrestrictedAnd then once you’ve run the install script for the fonts you can turn it back to the default:Set-ExecutionPolicy DefaultOnce the fonts have installed (it’ll take a bit because it pops up a window for each one), you can now set one of the Powerline fonts as the shell font in your terminal. To do this, simply open up your WSL terminal, right click on the top of the window, and select properties, then select the Font tab. Once there, you’ll want to set the font to anything that says Powerline in the name. I like the DejaVu Sans Mono one. It should look like the below: And you’re done! You should be able to close the WSL terminal window, re-open it, and you’ll have Powerline up and running. If it works, your terminal should now look like this: You can tweak Powerline to your hearts content with different colors, symbols, and such. Since I’m new to Powerline I don’t have much input on all these options but poke around the web and you’ll find plenty of things to tinker with.Getting Powerline working within VS CodeNow if you use VS Code like I do, you’ll want your integrated WSL terminal within VS Code to also have the Powerline goodness. This change is super simple because all that’s broken with the VS Code terminal is that it’s not using a Powerline font, but instead defaults to a different monospaced font.To make it work, simply open VS Code, open up Settings (File -&amp;gt; Preferences -&amp;gt; Settings or Ctrl+,). Then search for “Terminal Integrated Font Family”. Simply replace any font listed there with the Powerline font of your choice: And that’s it! Now you should have Powerline working in both the default WSL shell (or Windows Terminal) and also have it working in the integrated VS Code terminal.ConclusionThanks for reading! This was a super quick post about getting Powerline setup in WSL and VS Code. Let me know if it doesn’t work for you and how I might change it to make it better.I’d also like to give a quick shout out to DevPro Media and Bobby Johnson for their tutorials as they were the ones that helped me figure this out. You can find their posts on the subject here and here respectively." }, { "title": "Custom Cost Function for OMPL &amp; MoveIt! through ROS", "url": "/posts/ompl-cost-functions/", "categories": "development, tutorial", "tags": "ros, robotics", "date": "2019-10-29 12:00:00 -0500", "snippet": "This post has been a long time coming. If you’ve read some of my other tutorials you’ll notice that those development posts have all been helpful in getting to this point. In this post I’ll cover how to setup OMPL with a custom optimization objective that reaches out to the ROS stack for its cost function. This requires installing OMPL and MoveIt! from source and an addition to the OMPL source code that links OMPL to a ROS service that returns the cost value associated with a given state. All of this allows you to easily swap in custom cost functions that OMPL will use for optimizing planners (RRT*, etc.).This is a pretty lengthy walk through, but I hope you can see the potential of this kind of a system. It allows you to do two very powerful things: It allows you to easily add and modify optimization objectives (cost functions) for OMPL without having to touch the OMPL source code. This means that you can modify cost functions without having to recompile. Note also that you can even have the whole system running, take down your cost server and launch a new one without ever having to stop your main OMPL/MoveIt!/rviz client. Also you can see that your cost function doesn’t have to be written in C++. These demo ones are written in Python even though OMPL is written in C++! This system also allows for your cost functions to leverage the full power of the ROS stack. While OMPL has a limited understanding of the environment it operates in, your cost function can read from any ROS topic you’d like. This means your cost function can utilize sensor data or even user input which allows it to be a dynamic part of your system.This post will walk you through how to setup a development environment where you can have all of this running. By the end of this tutorial you should be able to write your own cost functions as ROS services that OMPL will pull from for its optimizing planners.NOTE: Like a lot of my previous posts, this is a functional solution and could definitely be improved (and in fact I am currently working on improving it). Please let me know of any improvements that you can think of.Initial SetupTo begin with, you’ll need a working development environment for OMPL and MoveIt!. I’ve already written a blog post on how to do this so check that out here. Walk through that post first with either a Docker or bare-bones Ubuntu/WSL and then come back here to walk through these addition steps.OMPL SetupOkay, so you now have a working OMPL and MoveIt! development environment. Now let’s get to the good stuff.First we need to checkout our custom planning branch for OMPL. You’ll remember from the installation walk-through that we cloned the CAIRO fork of OMPL. This already gives us access to the branch we need so we can simply move into the OMPL source directory and change branches:cd ~/ws_moveit/src/omplgit checkout custom-costNow that we’ve got a new version of OMPL checked out we’ll need to rebuild the workspace. However, before we do that we want to change a couple things.MoveIt! SetupFirst, we need to make a couple changes to the MoveIt! source code. This is so that MoveIt! will recognize our new optimization objective that will call out to our ROS service for a cost function. All we need to do is edit the file src/moveit/moveit_planners/ompl/ompl_interface/src/model_based_planning_context.cpp. Open this file up in your favorite text editor.cd ../src/moveitgedit ./moveit_planners/ompl/ompl_interface/src/model_based_planning_context.cppRight at the end of the include statements (around line 60) you’ll want to add the following include for our new objective #include&amp;amp;nbsp;&quot;ompl/base/objectives/CustomObjective.h&quot;. This means it will now look like the following:#include &quot;ompl/base/objectives/MaximizeMinClearanceObjective.h&quot;#include &quot;ompl/base/objectives/CustomObjective.h&quot; // Add our new objectiveompl_interface::ModelBasedPlanningContext...Now scroll down to the switch case defining the different optimization objectives (around line 295). Here you’ll need to add another else if case that will allow MoveIt! to recognize our new objective. The final code should look like the following: else if (optimizer == &quot;MaximizeMinClearanceObjective&quot;) { objective.reset(new ompl::base::MaximizeMinClearanceObjective(ompl_simple_setup_-&amp;gt;getSpaceInformation())); } else if (optimizer == &quot;CustomObjective&quot;) { // Add our new objective objective.reset(new ompl::base::CustomObjective(ompl_simple_setup_-&amp;gt;getSpaceInformation())); } else { objective.reset(new ompl::base::PathLengthOptimizationObjective(ompl_simple_setup_-&amp;gt;getSpaceInformation())); }Now MoveIt! should recognize our custom objective after we rebuild our workspace. Let’s do that now.sudo catkin buildCustom Cost Servers SetupNow for the good stuff! We can now add some custom cost servers to the mix. These can be whatever you’d like, but to demonstrate how they work, I’ve built a couple dummy ones in the CAIRO GitHub. Let’s clone that repo into our workspace.cd ~/ws_moveit/srcgit clone https://github.com/cairo-robotics/ompl_cost_server_demos.gitIf you take a quick look through the code, you’ll notice that this repo is a super basic ROS package that consists of a few cost servers. Let’s take a quick look at the random number one:#!/usr/bin/env pythonfrom ompl.srv import CustomCost, CustomCostResponseimport rospyimport randomdef handle_random_cost(request): cost = random.random() rospy.loginfo(&quot;Returning cost: %f&quot;%+-3cost) return costdef random_cost_server(): rospy.init_node(&#39;random_cost_server&#39;) rospy.Service(&#39;custom_cost&#39;, CustomCost, handle_random_cost) rospy.loginfo(&quot;Ready to compute random cost.&quot;) rospy.spin()if __name__ == &quot;__main__&quot;: random_cost_server()The main thing to note is that there is nothing special about this ROS service except that it imports the CustomCost srv file from the OMPL package and the service name is custom_cost. These two aspects are important since our fork of OMPL defines the srv file and is expecting to find a service waiting for calls with the name custom_cost. The srv file is located at ~/ws_moveit/src/ompl/srv/CustomCost.srv and is printed below:float64[] state---float64 costJust to make sure everything is set up properly, let’s build one more time and re-source the workspace.cd ~/ws_moveitsudo catkin buildsource ./devel/setup.bashTesting the SetupAlright, now let’s do a sanity check and make sure that everything works as intended. To do this, we’re going to follow a MoveIt! motion planning tutorial in rviz with the Panda robot arm. This will make sure that all the different components to our system are properly configured. This tutorial can be found on the MoveIt! docs website here, but I’ll include the steps below for the sake of completeness and since we need to make a slight change to get it working with our system.Before we run the demo, we need to first edit the ompl_planning.yaml file that configures how the demo interacts with OMPL. First we need to move into the panda_moveit_config package and then we need to edit the configuration file. You can open it in whatever text editor you prefer, but on my system I need to use sudo since it’s in the /opt directory.roscd panda_moveit_configsudo gedit config/ompl_planning.yamlAnd then add optimization_objective: CustomObjective inside the heading “RRTstarkConfigDefault” right under the “type” key. The final section should look like this: RRTstarkConfigDefault: type: geometric::RRTstar optimization_objective: CustomObjective range: 0.0 # Max motion added to tree. ==&amp;gt; maxDistance_ default: 0.0, if 0.0, set on setup() goal_bias: 0.05 # When close to goal select goal, with this probability? default: 0.05 delay_collision_checking: 1 # Stop collision checking as soon as C-free parent found. defaultBy making this change you’re requesting OMPL to use our custom objective. This can be changed through the rviz interface later on, but we’re setting the default here in the configuration and making sure the optimization_objective key exists. Note that we’ve only added this for the RRT* optimizing planner. If you wish to test this with other planners you’ll have to change those as well.Okay, so now the demo is configured properly we can walk through it and make sure everything works. Let’s go ahead and start the demo in rviz. I’ll let you follow along with the tutorial here. Go ahead and walk through all the steps if you’re unfamiliar with MoveIt! and rviz. Once you’re comfortable with it, come back here and let’s test our custom objective setup.All good? Alright, to run our custom objective we need to select the RRT* (RRTstarkConfigDefault) planner from the drop down in the MotionPlanning pane. It should like this: Now click on the Planning tab and then select Plan and Execute (note that your robot must have different start and goal positions for anything to happen). See below: Now if you go back to the terminal in which you ran the roslaunch command above, you should notice a bunch of warning messages saying something like:[ WARN] [1572387284.914557300]: Failed to call service custom_cost. Using clearance instead.This is because we haven’t started a ROS server that is ready to send out costs to OMPL. Since OMPL can’t find the server, it simply defaults to checking the clearance as the cost function for each state.In order to start our ROS cost server, we can simply launch it using the rosrun command from another terminal (assuming the ROS master node is still running from our roslaunch command):rosrun ompl_cost_server_demos random_cost.pyThe above command runs the server we showed the code for above. This server simply publishes random values for the cost to OMPL.Now that we have that running, go back to rviz and move the start and goal positions of the arm. Once that is done, click Plan and Execute again to make OMPL attempt to find a solution.If all worked correctly you should see something like the following output from the server node:[INFO] [1572387558.281799]: Returning cost: 0.743727This means that OMPL is asking your server for the cost of different states and everything is working!ConclusionThis was a pretty lengthy walk through, but I hope you haven’t lost sight of the potential of this kind of a system. It allows you to do two very powerful things: It allows you to easily add and modify optimization objectives (cost functions) for OMPL without having to touch the OMPL source code. This means that you can modify cost functions without having to recompile. Note also that you can even have the whole system running, take down your cost server and launch a new one without ever having to stop your main OMPL/MoveIt!/rviz client. Also you can see that your cost function doesn’t have to be written in C++. These demo ones are written in Python even though OMPL is written in C++! This system also allows for your cost functions to leverage the full power of the ROS stack. While OMPL has a limited understanding of the environment it operates in, your cost function can read from any ROS topic you’d like. This means your cost function can utilize sensor data or even user input which allows it to be a dynamic part of your system.Please let me know if any of this doesn’t work for you or if you have comments or improvements to offer. This is a project I’m actively working on and hope to implement some cool cost functions using this methodology. Hope this helps you as well!" }, { "title": "Installing RealSense SDK on an ODROID-XU4", "url": "/posts/realsense-sdk-odroid/", "categories": "development, tutorial", "tags": "ros, robotics", "date": "2019-09-30 12:00:00 -0500", "snippet": "In this post I’ll walk through how to get the RealSense SDK up and running on the ODROID-XU4. This might seem trivial at first, but the steps can be a bit confusing.For this tutorial I’ll assume you’re running Ubuntu 16.04 MATE with the 4.14 kernel on your ODROID. You can get this image from their website here and flash it to your ODROID’s storage using Baleena Etcher here.As long as you’ve got that working, let’s proceed. I’m basically going to run through the instructions that Intel provides on their GitHub here, but with a slight modification for the d435i. All that said, the setup is pretty straight forward though the actual install itself may take a while since the ODROID isn’t the fastest thing.Getting startedFirst, we need to make sure everything on our system is up to date. To do that run:sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade &amp;amp;&amp;amp; sudo apt-get dist-upgradeFor the following steps you’ll need git and gedit so let’s install those now since they don’t come preloaded on the ODROID’s OS:sudo apt install git geditNow go to a directory where you want to clone your repositories and then pull down their Git repo:git clone https://github.com/IntelRealSense/librealsense.gitNavigate to the librealsense root directory before running the following commands:cd librealsenseAnd now we’ll install all the development tools needed to build the package:sudo apt-get install git libssl-dev libusb-1.0-0-dev pkg-config libgtk-3-dev libglfw3-dev g++ build-essential cmakeWe also need to run a permissions script which will setup the proper udev rules. Run this below:./scripts/setup_udev_rules.shPatching for ODROID &amp;amp; d435iNow an important step for the ODROID with the 4.14 kernel is to run a patch provided by Intel. This is included in the repo you cloned before so simply run this command:./scripts/patch-realsense-ubuntu-odroid.shNow before we build the package, we must first make a slight change to the source code to make it compatible with the d435i. This is due to the fact that the d435i has an integrated IMU which doesn’t work with the ODROID and causes the device to fail on connection. To make this change we’ll run the following command to edit the problem file:gedit src/ds5/ds5-factory.cppNow in the gedit window scroll way down to the line that says all_sensors_present &amp;amp;= (hids.capacity() &amp;amp;gt;= 2); and change the 2 to 1. And that’s it! Save the file and close the gedit window to return back to your terminal window.Building and InstallingNow we’re ready to finally build and install the package. From the root of the librealsense repository, run the command below to make a build directory and navigate to it:mkdir build &amp;amp;&amp;amp; cd buildNow we’ll run our cmake command to set everything up with a couple flags:cmake ../ -DBUILD_EXAMPLES=true -DBUILD_GRAPHICAL_EXAMPLES=falseNow is the big moment! We’re finally going to build and install the librealsense package. Below I have the make command running in a single thread which runs very slowly, but I had issues with the ODROID locking up if I tried to multithread the build (I’m guessing this is due to RAM limitations on the board). If you want to, go ahead and try multithreading it by adding the flag-j# (where you can replace the # to any number of threads you want) to the solo make command.sudo make uninstallmake cleanmakesudo make installConclusionIf everything went well you should now be able to reboot your machine (sudo reboot now) and then plug in your d435i and it should all work. Try running the command rs-color and you should see a bunch of output demonstrating that the ODROID is now reading input from the Realsense.If you have any issues with the above steps double check what I’m doing with the commands from Intel here and here and then let me know how I can update this to make it better. Hope this helps!" }, { "title": "Setting up ROS in Windows through Docker", "url": "/posts/ros-windows-docker/", "categories": "development, tutorial", "tags": "ros, robotics", "date": "2019-09-11 12:00:00 -0500", "snippet": "In another post, I wrote about setting up a ROS development environment within Windows using WSL. Since then, I’ve had a few people ask me about setting up the same system except using Docker. This is very straight forward since there are already pre-built ROS images out on Docker Hub. These can easily be pulled and run with minimal configuration to get it working.NOTE #1: This installation will set up ROS Kinetic. The same steps will also install any other version of ROS you’d like to use (like Melodic), but you’ll need to change any commands with the word kinetic in them to the ROS distribution of your choice.NOTE #2: If you’d like to know how to set this up in WSL, I have a tutorial here.Docker SetupTo begin, you first will have to install Docker and then open a Powershell window. To make sure that Docker is running, you can use the command docker ps. If you get an error, you don’t have Docker properly setup or running on your machine. You can troubleshoot here.If everything is working, you can now run the below command which will pull down the pre-built ROS image from Docker Hub:docker pull osrf/ros:kinetic-desktop-fullThis will take a bit of time depending on the speed of your network and machine. Once that that is downloaded and extracted, we can run this image to start up our ROS container.docker run --name ros-dev -it osrf/ros:kinetic-desktop-full bashThe above command does a few things: docker run simply states that we wish to run a Docker image and turn it into a container. --name ros-dev is naming the container (you can use any name you want instead of ros-dev). -it {image_name} bash basically means we want to run the container interactively (ie. we wish to ssh into it and use bash). osrf/ros:kinetic-desktop-full is simply the image name we wish to run as a container. I am using the desktop-full version of ROS here, but there are smaller images out there that work as well. They just require other packages to be installed later for advanced functionality.Once this command runs, you should be popped straight into the shell of your new ROS container. We still need a little configuration to properly set it up though.ROS SetupFirst, we need to make sure we are sourcing ROS whenever we enter our ROS container. To do this, simply run:echo source &quot;/opt/ros/kinetic/setup.bash&quot; &amp;gt;&amp;gt; ~/.bashrcThis will add the ROS sourcing script to your .bashrc file so that it will be loaded every time you create a new terminal. Now we need to source it for our current terminal:source ~/.bashrcNow let’s see if our ROS installation is properly working:roscoreIf you get something like the following, you’re system is working correctly!... logging to /root/.ros/log/58f66bc2-d4a4-11e9-be85-02420aff0002/roslaunch-59fe088dbe6a-325.logChecking log directory for disk usage. This may take awhile.Press Ctrl-C to interruptDone checking log file disk usage. Usage is &amp;amp;lt;1GB.started roslaunch server http://59fe088dbe6a:34269/ros_comm version 1.12.14SUMMARY========PARAMETERS * /rosdistro: kinetic * /rosversion: 1.12.14NODESauto-starting new masterprocess[master]: started with pid [335]ROS_MASTER_URI=http://59fe088dbe6a:11311/setting /run_id to 58f66bc2-d4a4-11e9-be85-02420aff0002process[rosout-1]: started with pid [348]started core service [/rosout]You’ve got a perfectly good ROS development environment all set up at this point. Anytime you want to develop in ROS, simply open a Powershell window and run the command below (make sure to substitute in the container name you chose to use before:docker exec -it ros-dev bashHowever, if you really want to have the perfect setup, you’ll want to set up the ability to run graphical applications like rviz and rqt_console. See the below steps for this functionality.Setup GUI ForwardingThere are many X-server applications that will allow for GUI forwarding to Windows, but my favorite one is VcXsrv. Go here to download and install it.Once you run the installer you may need to launch it from Start in order to set it up. You can simply press “next” a few times to accept all the defaults and then select “finish” to close it out. You should now see it’s icon down in your icon tray which means the server is running. Note: right before you click “finish” you can select “Save configuration” so that you can simply double-click the config file to launch VcXsrv with all the defaults. This is a bit faster than clicking through every time.Note: You may want to uncheck “Native opengl” and check “Disable access control”. On different systems I’ve had issues with the defaults here. Your mileage may vary. Example of adjusting VcXsrv settings Once that’s set up, you can now jump into your ROS container and setup the necessary bits on that side. Open a new Powershell window and launch an interactive shell into your ROS container using the command we used before:docker exec -it ros-dev bashOnce you’re in the container, we need to set the DISPLAY environment variable which tells the container where to send the graphics for any application that needs a display to function. To do this, you’ll need to know the IP address for the Windows host machine. You can find this by going to Settings -&amp;amp;gt; Network &amp;amp;amp; Internet and looking under the properties of your current connection (it will probably be labeled as “IPv4 Address”). Then run this command and replace the placeholder with your IP address:echo &#39;export DISPLAY={your_ip_address}:0.0&#39; &amp;gt;&amp;gt; ~/.bashrcNOTE: If you’re running this on a laptop then your IP address will change as you move from network to network. Also, if you’re on a larger network (at a school campus or big company) you’re IP may change from time to time. Just keep this in mind that you may need to update this every once in a while.Now source your edited .bashrc file:source ~/.bashrcAnd run the roscore command to launch your ROS master node.Finally, you’ll need to open up another ROS terminal through another Powershell window and then run the below command to test out your GUI forwarding:rqt_consoleIf everything went correctly you should see the console window pop up on your screen! Example of the rqt_console window And that’s it! You’ll now be able to develop in ROS with GUI applications such as the console and rviz.ConclusionSo there it is. That’s how you can set up a fully featured ROS development environment within Docker on Windows. Keep in mind that networking and USB device support will be difficult to manage with this setup (but not necessarily impossible).I hope this is helpful to some of you and let me know if you have any further questions or comments." }, { "title": "Setting up ROS in Windows through WSL", "url": "/posts/ros-windows-wsl/", "categories": "development, tutorial", "tags": "ros, robotics", "date": "2019-06-24 12:00:00 -0500", "snippet": "UPDATEThis post is now deprecated with the public launch of WSL2. I have a new post documenting how to do this same set up with WSL2. Check it out over here.NOTE: If you are not running Windows 10 2004 Build 19041 or higher, then you can continue with this post using WSL1.IntroductionAs a robotics researcher, I spend a lot of my time developing in a Linux-on-metal environment. This is because my work revolves around ROS (the Robot Operating System) which requires Ubuntu in order to run. If you want an intro to ROS and the power of working with this highly-extensible software I’ll point you to the ROS website which has many good resources explaining the abilities of this system. Ubuntu in and of itself is not a bad platform, but growing up as a Windows guy I’ve come to love Microsoft’s platform and many of the features and native apps that follow from it (who doesn’t love native, highly supported gaming and a rich ecosystem of powerful professional grade apps?). Plus, no Linux distribution I’ve ever used has quite the polish of Microsoft’s offering.Because of this, I’ve often wanted a way to develop within ROS on top of Windows. This can be accomplished by spinning up a VM within VirtualBox or VMWare and simply diving into a full Ubuntu desktop, but that takes up precious resources and also means dealing with all the miscellaneous issues with a full Linux install that I’m trying to avoid. Put simply, I wish for a lightweight ROS development environment which will allow me to quickly jump in and out of it without slowing down my Windows host. There are two ways to accomplish this: one way is to simply load up a Docker image based on Ubuntu with ROS pre-installed and away you go. However, Docker containers don’t have a great connection with either your network or your local files and thus aren’t tightly integrated with the Windows platform they are hosted by. The second way to accomplish this is by using WSL (Windows Subsystem for Linux) which is what we will do below.NOTE: If you’d like to know how to set this up in Docker, I have a tutorial here.WSL InstallationWSL is simply an emulation of Linux on top of Windows. With WSL 1 this is not quite a VM but also not quite bare-bones and is kind of a mongrel of an OS. You can find a good overview of how it works here. However, it works very well (except for file system performance which we’ll get into a little later) and can handle our ROS needs with ease.NOTE: As I am writing this WSL 2 is in the works which uses a super light-weight VM on Hyper-V in order to create a fully fledged Linux environment with (almost) all the power of bare-bones Linux. I actually use WSL 2 for my development systems, but you have to run a Windows Insider version for that to work right now. I’ll write an updated post when WSL 2 officially goes live in Spring 2020.The first step of setting up this ROS development environment on Windows is simply to enable the WSL feature and then install your preferred Linux distribution. Microsoft has a tutorial here about how to do it, but for the sake of continuity I’ll also put it in this walk-through.To enable WSL, open up PowerShell as Administrator and run this command:Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-LinuxThis will only take a second or two to run (it’s really just flipping a switch internally on Windows) and then you’ll need to reboot your machine. During the reboot process you’ll see that it’s installing new features (that’s our WSL stuff!) and then you’ll be good to go.Now you can head over to the Microsoft Store app and search for “linux”. Click &quot;Show all&quot; to see all Linux distros (including Ubuntu 16.04) This will give you a bunch of options including Kali, Ubuntu, Debian, and others. For ROS we need Ubuntu installed and, since I spend most of my time on ROS Kinetic, I will choose Ubuntu 16.04 LTS. At the time of writing the store lists, Ubuntu, Ubuntu 16.04 LTS, and Ubuntu 18.04 LTS. If you’d like, you can install Ubuntu 18.04 LTS and then later on install ROS Melodic, but I will proceed in this walk-through assuming 16.04/Kinetic.NOTE: Keep in mind that Ubuntu and ROS versions are paired with each other: 16.04/Kinetic and 18.04/Melodic. They don’t work interchangeably.All that being said, simply click on your Ubuntu version of choice and then click install. This will take a bit depending on your internet speeds since the distribution is fairly large. Once it’s done though you’ll have a new app with the Ubuntu logo on it and the name Ubuntu 16/18.04 (depending on which one you chose).Now we can launch that app and it will take a bit the first time as it needs to run through the initialization of the OS (remember that we are installing a complete operating system here). However, every other boot of WSL will only take a couple of seconds.Once the initialization is complete you’ll need to create a username and password that you’ll use any other time you want to enter the WSL distribution.Now you’re in! You have an (almost) fully-featured version of Ubuntu running within Windows with minimal resources being taken up and the ability to launch and kill it in a matter of seconds.NOTE: Your WSL file system resides within your file explorer at \\\\wsl$\\Ubuntu-16.04 if you’re running Windows 10 19.03 or later).WSL Extras (optional, but highly recommended)These are a couple things that I always do in order to boost my WSL productivity. The first is to keep Windows Defender from constantly scanning WSL files (this boosts file system performance in WSL) and the second is to add an X-server to run GUI applications in Windows through WSL. We’ll tackle these below.Add WSL to the Exclusions ListNOTE: This may only work for Windows 19.03 or later. Go ahead and try it though anyway and let me know how you get on if you’re running some earlier build.First, open up the Windows Security app. Then click on “Virus &amp;amp; threat protection”. Click on &quot;Virus &amp;amp; threat protection&quot; Now under “Virus &amp;amp; threat protection settings” you’ll see a “Manage settings” option; click that. Click on &quot;Manage settings&quot; Scroll way down to the bottom of the page and under “Exclusions” you’ll see an option for “Add or remove exclusions”; click that. Click on &quot;Add or remove exclusions&quot; Now you’ll need to press the + next to “Add an exclusion” and then select “folder”. You should now be able to type in your WSL file system location ( \\\\wsl$\\Ubuntu-16.04) and press enter. Once finished, the exclusion should look like this Setup GUI forwardingThere are many X-server applications that will allow for GUI forwarding from WSL, but my favorite one is VcXsrv. Go here to download and install it.Once you run the installer you may need to launch it from Start in order to set it up. You can simply press “next” a few times to accept all the defaults and then select “finish” to close it out. You should now see it’s icon down in your icon tray which means the server is running.NOTE #1: right before you click “finish” you can select “Save configuration” so that you can simply double-click the config file to launch VcXsrv with all the defaults. This is a bit faster than clicking through every time.NOTE #2: You may want to uncheck “Native opengl” and check “Disable access control”. On different systems I’ve had issues with the defaults here. If you do this, be sure to set the environment variable LIBGL_ALWAYS_INDIRECT=0 in your WSL terminal (you can just add export LIBGL_ALWAYS_INDIRECT=0 to the end of your .bashrc file). Your mileage may vary. Example of adjusting VcXsrv settings Once that’s set up, you can now open your Ubuntu app and run this command to setup the GUI forwarding by adding an export of the DISPLAY variable to your .bashrc file. This way you’ll have this environment variable set with every new shell you open up:echo &#39;export DISPLAY=:0&#39; &amp;gt;&amp;gt; ~/.bashrcNow source your edited .bashrc file:source ~/.bashrcNow everything should be setup for GUI apps to be sent on to Windows for rendering and display. If you want to test the setup, you can install some basic apps within Ubuntu with the below package:sudo apt updatesudo apt install x11-appsAnd then run:xcalcTo run one of the apps. Or you can install any of your favorite GUI apps or test it with ROS after we install that. Speaking of which…ROS InstallationNow to install ROS. The ROS team has a great installation guide over here at their website, but like before I’ll go ahead and show it here for completeness. Again note that the below commands are for Ubuntu 16.04/ROS Kinetic. If you chose to go with 18.04/Melodic you’ll need to alter these a tiny bit. Go here for more details.First we need to add the ROS packages information to the sources list on our WSL system. To do this, open your Ubuntu app and run the below command:sudo sh -c &#39;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &amp;gt; /etc/apt/sources.list.d/ros-latest.list&#39;Now we need to setup the keys for these package repositories:sudo apt-key adv --keyserver &#39;hkp://keyserver.ubuntu.com:80&#39; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654NOTE: If you get some errors with the above command try substituting hkp://pgp.mit.edu:80.Now we need to update the local list of available packages with these newly added ROS ones:sudo apt updateNow we’re (finally) ready to install ROS. There’s a few options to choose from: desktop-full: This includes everything; rqt, rviz, simulators, navigation, perception, you name it. desktop: This has most of the above but lacks the simulators, navigators, and perception. ros-base: This is just the basics for getting up and running with ROS. No GUI tools and only what you need to package, build, and communicate over the ROS stack.My recommendation is to go with desktop-full unless you are super short on storage. It’ll take a bit more time for the initial install and take up more disk space, but you’re guaranteed to have most of the tools you need for anything you’d like to do. However, with all of these you can simply add more tools as you need them. Simply run apt-cache search ros-kinetic to find which ones are available.Once you’ve chosen the ROS installation you want to get, run the below command and substitute in your choice. I’ll do desktop-full here:sudo apt install ros-kinetic-desktop-fullThis will take a long time to run. Remember when I said file system performance is bad on WSL? This is because it’s actually an emulated Linux file system on a Windows file system (this is changing in WSL 2). Don’t worry though, the actual performance of ROS when it’s running in WSL is pretty zippy.Once it’s done with the install we need to initialize the dependency manager for ROS. Simply run these two commands:sudo rosdep initrosdep updateROS needs to be sourced each time you open a bash shell and so we can add it to the ~/.bashrc file using the below commands to add it and source it (you can source ROS every time but that defeats the point of making this a dedicated ROS development environment):echo &quot;source /opt/ros/kinetic/setup.bash&quot; &amp;gt;&amp;gt; ~/.bashrcsource ~/.bashrcOne last thing to do. For most ROS development you’ll want to be able to build your own packages. So we need a couple more packages in order to make this work. So finally we run this last install command:sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essentialAnd you’re done! Welcome to ROS on Windows!ConclusionThough this post is pretty long, none of this is actually too hard to setup and can be done in a matter of a few minutes (plus install times). It offers a fairly painless way to get started in ROS development on Windows for those who don’t want to run a VM or dual-boot their systems.Once everything has been done above, you’re ready for some ROS development. Not everything will be supported in ROS with this setup (networking across devices may be a bit tricky though I’ve never tested it to see), but the basics are all there for most development. If you’re new to ROS, I’d suggest walking through all of the tutorials here to get a handle on things. At least go through the Beginner Level (you can just do one or the other of the C++ and Python ones) so that you have a good foundation to work off of.I hope this is helpful to somebody and if you have any thoughts on how to improve don’t hesitate to let me know with a comment." }, { "title": "Installing OMPL/MoveIt! for custom motion planning", "url": "/posts/ompl-moveit-custom-motion-planning/", "categories": "development, tutorial", "tags": "ros, moveit, motion planning, robotics", "date": "2019-06-24 12:00:00 -0500", "snippet": "IntroductionI am in the process of creating a customized version of an OMPL planner that uses a personalized costmap to help robots learn to move around people in a more comfortable way. In order to do this, I needed a development environment that included ROS, OMPL, and MoveIt!. Specifically, I needed both OMPL and MoveIt! to be installed from source in order to augment their code so that I could add my customizations to OMPL and have MoveIt! use my custom planner within OMPL.I naively thought at first that setting up this development environment would be easy. I found this handy tutorial on web.archive.org (the fact that it’s archived should have been a red flag to me) and attempted to follow its super basic instructions. Turns out that OMPL and MoveIt! have some dependencies that must be installed in a particular way in order for everything to install properly. Through a lot of hacking, installing, reinstalling, and much head-banging, I finally figured out an installation process that leads to (what seems to be) a fully functional development environment for OMPL and MoveIt!.I have worked out a couple methods to getting this working: This is a simple shell script I wrote that installs everything you need on a clean Ubuntu system. (preferred) This method builds a container in Docker.NOTE #1: I am not an experienced C++ developer and so there may be inaccuracies in my explanation below and my methodology may be hacky/downright wrong. I welcome any and all comments to improve this system.NOTE #2: If you want to develop in ROS but don’t necessarily need custom installs of OMPL or MoveIt! and also happen to use Windows, I’ve written up a couple tutorials showing how to get ROS working on Windows using either WSL here or Docker here.Installation (Ubuntu Desktop)Before we begin, a couple things to note. First, this process should work well on a relatively clean version of Ubuntu 16.04 desktop. I would suggest using a VM (or WSL first as it is guaranteed to be completely clean and so without any conflicting dependencies (the bane of my existence while figuring all this out).Now, open a terminal window and download the install script from my GitHub:wget https://raw.githubusercontent.com/jgkawell/docker-scripts/master/Linux/ompl-install.shNOTE: The contents of this file are explained in full below if you want to know what exactly it does.You may need to make the file executable:chmod +x ompl-dev-install.shAnd finally, simply run the script and wait a while (the length will depend on the speed of your machine and internet connection):./ompl-dev-install.shAnd that should be it! Keep reading below if you’d like a full explanation of the installation script thoughInstallation (Docker)This method will set up everything you need for development within a Docker container. This is my preferred method as it is super repeatable and can easily be nuked and rebuilt without any hassle. It does require a tad bit more initial setup though.X server (GUI forwarding)Now before we get started, we need to first set up the X-server on the host in order to pipe through GUI applications (think rqt_console, rviz, etc.). This is done differently if you’re on a Windows or Linux host.Windows HostIf you’re running Windows, I’d suggest installing VcXsrv and then I have a pre-built configuration file that you can simply run to have the X server ready to go (it’s under docker-scripts/Windows in this git repository.In addition to installing and setting up your X-server application, you’ll also need to set the DISPLAY environment variable so that the Docker container knows where to push GUI applications. For that, if you’re on Windows, run the below command in Powershell and remember to fill in your correct IP address (IP can be found in Settings -&amp;gt; Network &amp;amp; Internet -&amp;gt; Wi-Fi or Ethernet -&amp;gt; Click on the connection -&amp;gt; IPv4 address):[Environment]::SetEnvironmentVariable(&quot;DISPLAY&quot;, &quot;{MY_IP_ADDRESS}:0.0&quot;)NOTE: This variable “unsets” itself for some reason if you change consoles or restart. You can check to see if this variable is still set by using the command Get-ChildItem Env:.Linux HostIf you’re running a Linux host… {coming soon}StartupNow that our X server is setup, install Docker and then open a terminal/Powershell window and clone my git repository to get the necessary Docker files:git clone https://github.com/jgkawell/docker-scripts.gitNow move into the ompl directory within the repository:cd docker-scripts/omplAnd now we can run our favorite command to launch the system:docker-compose upThis will take a while to run, but at the end it will have built an image called jgkawell/ompl-dev:basic and brought up a container called ompl-dev-basic. You can then ssh into the container with the typical command:docker exec -it ompl-dev-basic bashAnd from there you should have everything you need good to go. The container has tmux built in for multi-pane support (you’ll notice there’s a tmux config file that is copied into the container and sets up some of the most commonly used features like mouse support) as well as GUI forwarding. Go ahead and run through some ROS and MoveIt! tutorials to check things out and happy hacking!Installation (shell script overview)Here is the installation script in full. The Dockerfile and docker-compose.yaml are very similar to the below code so if you’re wondering how those work you can look here for answers. Note that the sequence of installation is very important as each install requires one or more of the previous libraries to either install or function properly.Install misc needed packages# Install misc needed packagessudo apt -y updatesudo apt -y upgradesudo apt -y install git build-essential cmake wgetThis section just installs some basic packages we’ll need for the installation of everything below.NOTE: In a previous version of this post I had custom installations of libccd, fcl, and octomap. Turns out these are unnecessary as MoveIt! will install the needed versions for our source OMPL install.Install ROS# Install ROS (https://ros.org/install):sudo sh -c &#39;echo &quot;deb http://packages.ros.org/ros/ubuntu xenial main&quot; &amp;gt; /etc/apt/sources.list.d/ros-latest.list&#39;sudo apt-key adv --keyserver &#39;hkp://keyserver.ubuntu.com:80&#39; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654sudo apt -y updatesudo apt -y install ros-kinetic-desktopsudo rosdep init &amp;amp;&amp;amp; rosdep updateecho &quot;source /opt/ros/kinetic/setup.bash&quot; &amp;gt;&amp;gt; ~/.bashrcsudo apt -y install python-rosinstall python-rosinstall-generator python-wstoolAnyone familiar with ROS will recognize these steps. One little change I took was to replace the lsb_release call with simply defining our version as xenial. The reason being that I didn’t want to install the lsb-release package and this script is only designed to work with 16.04/Kinetic anyway. Also you’ll notice that I install the desktop version of ROS and not desktop-full. This means that MoveIt! won’t be installed as a package and we can install it hassle free from source below. Also, MoveIt! will install all the needed GUI tools for robot simulation so installing them with desktop-full is unnecessary.Install MoveIt!# Install MoveIt! (https://moveit.ros.org/install/source/):rosdep updatesudo apt -y install python-catkin-tools clang-format-3.9cd ~/mkdir ws_moveitcd ws_moveitwstool init srcwstool merge -t src https://raw.githubusercontent.com/ros-planning/moveit/master/moveit.rosinstallwstool update -t srcrosdep -y install --from-paths src --ignore-src --rosdistro kineticcatkin config --extend /opt/ros/kinetic --cmake-args -DCMAKE_BUILD_TYPE=Releaseconfig --blacklist \\ moveit_chomp_optimizer_adapter \\ moveit_planners_chomp \\ chomp_motion_plannercatkin buildecho &quot;source ~/ws_moveit/devel/setup.bash&quot; &amp;gt;&amp;gt; ~/.bashrcThis installation is taken directly from the link in the code. You’ll notice that I don’t setup ccache and I add chomp to the blacklist but other than that this is pretty much just as it is in the MoveIt! tutorial.Setup OMPL# Install OMPL (http://ompl.kavrakilab.org/installation.html):sudo apt -y install pkg-config libboost-serialization-dev libboost-filesystem-dev libboost-system-dev libboost-program-options-dev libboost-test-dev libode-devcd ~/ws_moveit/srcgit clone https://github.com/cairo-robotics/ompl.gitcd omplgit checkout tags/1.2.3This section simply installs a bunch of needed packages for OMPL and clones the source code into our MoveIt! workspace. Note that this clones the CAIRO fork of OMPL. This isn’t necessary unless you’re going using my technique for creating custom cost functions in OMPL spelled out in more detail here. It also makes sure to checkout tag 1.2.3 as this is the OMPL version for ROS Kinetic.# Make some changes to build files so OMPL will be found by MoveIt!cd ~/ws_moveitsed -i &quot;s|DESTINATION \\${CMAKE_INSTALL_LIBDIR}|DESTINATION /opt/ros/kinetic/lib/x86_64-linux-gnu |g&quot; ./src/ompl/src/ompl/CMakeLists.txtsed -i &quot;s|\\${catkin_INCLUDE_DIRS}|\\${OMPL_INCLUDE_DIRS} |g&quot; ./src/moveit/moveit_planners/ompl/CMakeLists.txtsed -i &quot;s|\\${OMPL_INCLUDE_DIRS})|\\${catkin_INCLUDE_DIRS}) |g&quot; ./src/moveit/moveit_planners/ompl/CMakeLists.txt# MoveIt! needs the package.xml file in order to locate OMPL for buildingcd ~/ws_moveit/src/omplwget https://raw.githubusercontent.com/ros-gbp/ompl-release/debian/kinetic/xenial/ompl/package.xmlIn order for everything to build properly, we need to edit a couple files in the workspace. The first one tells OMPL to install itself over the default OMPL that is installed with MoveIt! (source). The second one tells MoveIt! to look for OMPL before catkin directories (source). And finally we have to download the package.xml into the OMPL directory so that MoveIt! will include it in the build process (source).Install OMPL# Finally install MoveIt! with our source OMPLcd ~/ws_moveitsudo catkin clean -ysudo catkin build # sudo is needed since we install OMPL in /optsource ~/.bashrcFinally the real reason that we’re here! At first I thought you had to install OMPL according to the instruction on their site. But it turns out that you can install it alongside MoveIt! and it “just works”. First we clean the workspace and then we build it. I added in a re-sourcing of the .bashrc file just for good measure.ConclusionSo there it is. It took me weeks to finally figure out this particular solution and I’m posting it here to hopefully save some others the time and hassle I went through. Again I want to reiterate that this is simply a functional solution and definitely not optimal. If anyone reads this and has suggestions on how to slim this down or decrease compile time (I’m considering packaging this up as a Docker image on Docker Hub so that install faster) I’d welcome any and all feedback. Please leave them in the comments below." } ]
